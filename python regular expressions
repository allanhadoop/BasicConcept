# Source - http://www.w3resource.com/python-exercises/re/index.php
# All symbols here -- https://www.tutorialspoint.com/python/python_reg_expressions.htm
# Regular expressions use the backslash character ('\') to indicate special 
# forms or to allow special characters to be used without invoking their special meaning.
# More details  - https://docs.python.org/2/library/re.html

----------------------------------------------------------
\s Match a whitespace character: [ \t\r\n\f]
\S Match nonwhitespace: [^ \t\r\n\f]
\d Match a digit: [0-9]
\D Match a nondigit: [^0-9]
\w Match a single word character: [A-Za-z0-9_]
\W Match a nonword character: [^A-Za-z0-9_]
$ Matches the end of the string or just before the newline at the end of the string
---------------------------------------------------------- 
'*'
Causes the resulting RE to match 0 or more repetitions of the preceding RE, 
as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s.
'+'
Causes the resulting RE to match 1 or more repetitions of the preceding RE. 
ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’.
'?'
Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’.
'.'
(Dot.) In the default mode, this matches any character except a newline. 
'^'
(Caret.) Matches the start of the string,
'$'
Matches the end of the string or just before the newline at the end of the string
---------------------------------------------------------- 
# to check that a string contains only a certain set of characters (in this case a-z, A-Z and 0-9)  
import re
def is_allowed_specific_char(string):
    charRe = re.compile(r'[^a-zA-Z0-9.]')
    string = charRe.search(string)
    return not bool(string)                  #This 'not' means not True or not False
print(is_allowed_specific_char("ABCDEFabcdef123450")) 
print(is_allowed_specific_char("*&%@#!}{"))
Output -- 
True
False
---------------------------------------------------------- 
# program that matches a string that has an a followed by either no b's or more b's.  
import re
def textmatch(text):
    pattern = 'ab*?'
    if re.search(pattern,text):
        return 'Found a match'
    else:
        return 'No match found'
print(textmatch("a"))
print(textmatch("abc"))
print(textmatch("sd"))
Output -- 
Found a match
Found a match
No match found
---------------------------------------------------------- 
# program that matches a string that has an a followed by one or more b's. 
def textmatch(text):
    pattern = 'ab+?'
    if re.search(pattern,text):
        return 'Found a match'
    else:
        return 'No match found'

print(textmatch("a"))
print(textmatch("abc"))
print(textmatch("adb"))
Output -- 
No match found
Found a match
No match found
---------------------------------------------------------- 
# program that matches a string that has an a followed by zero or one 'b'  

def textmatch(text):
    pattern = 'ab??'
    if re.search(pattern,text):
        return 'Found a match'
    else:
        return 'No match found'
print(textmatch("a"))
print(textmatch("abc"))
print(textmatch("adb"))
Output -- 
Found a match
Found a match
Found a match
---------------------------------------------------------- 
# program that matches a string that has an a followed by three 'b'  
# {m}
Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not 
to match. For example, a{6} will match exactly six 'a' characters, but not five.
def textmatch(text):
    pattern = 'ab{3}?'
    if re.search(pattern,text):
        return 'Found a match'
    else:
        return 'No match found'

print(textmatch("a"))
print(textmatch("abbbc"))
print(textmatch("adbbb"))
Output -- 
No match found
Found a match
No match found
---------------------------------------------------------- 
# program that matches a string that has an a followed by two to three 'b'.  
def textmatch(text):
    pattern = 'ab{2,3}?'
    if re.search(pattern,text):
        return 'Found a match'
    else:
        return 'No match found'
print(textmatch("ab"))
print(textmatch("abbc"))
print(textmatch("abbbcc"))
Output -- 
No match found
Found a match
Found a match
---------------------------------------------------------- 
# to find sequences of lowercase letters joined with a underscore.  
import re
def textmatch(text):
    pattern = '^[a-z]+_[a-z]+$'             # ^ for match at beginning of the string and $ for end of the string
    if re.search(pattern,text):
        return 'Found a match'
    else:
        return 'No match found'
print(textmatch("aab_cbbbc"))
print(textmatch("aab_Abbbc"))
print(textmatch("aabbb_ccdee"))
Output -- 
Found a match
No match found
Found a match
---------------------------------------------------------- 
# that matches a string that has an 'a' followed by anything, ending in 'b'. 
def text_match(text):
    patterns = '^a.*?b$'
    if re.search(patterns, text):
        return 'Found a match!'
    else:
        return ('Not matched!')
print(text_match("asdfs"))
print(text_match("a#$%$#%$#%b"))
print(text_match("aabbbbc"))
print(text_match("aabAbbbc"))
print(text_match("ABCDEF"))
Output---
Not matched!
Found a match!
Not matched!
Not matched!
Not matched!
---------------------------------------------------------- 
# that matches a word at the beginning of a string
def text_match(text):
    patterns = '^\w+'
    if re.search(patterns, text):
        return 'Found a match!'
    else:
        return ('Not matched!')
print(text_match("The quick brown fox jumps over the lazy dog."))
print(text_match(" The quick brown fox jumps over the lazy dog."))
Output -- 
Found a match!
Not matched!
---------------------------------------------------------- 
{m}  
Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. 
For example, a{6} will match exactly six 'a' characters, but not five.
----------------------------------------------------------
{m,n}
Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible. 
For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and 
omitting n specifies an infinite upper bound. 
As an example, a{4,}b will match aaaab or a thousand 'a' characters followed by a b, but not aaab.
----------------------------------------------------------
{m,n}?
Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match 
as few repetitions as possible. This is the non-greedy version of the previous qualifier.
----------------------------------------------------------
'\'
Either escapes special characters (permitting you to match characters like '*', '?', and so forth),
----------------------------------------------------------
[amk] will match 'a', 'm', or 'k'.
[0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit
[(+*)] will match any of the literal characters '(', '+', '*', or ')'
[^5] will match any character except '5', and [^^] will match any character except '^'
both [()[\]{}] and []()[{}] will both match a parenthesis.
zy? will match either ‘z’ or ‘zy’.
----------------------------------------------------------
A|B, where A and B can be arbitrary REs, creates a regular expression that will match either A or B.
(...) Matches whatever regular expression is inside the parentheses,
(?#...)A comment; the contents of the parentheses are simply ignored.
----------------------------------------------------------
(?<=...)
Matches if the current position in the string is preceded by a match for ... that ends at the current position.
m = re.search('(?<=abc)def', 'abcdef')
Output -- 'def'
----------------------------------------------------------
m = re.search('(?<=-)\w+', 'spam-egg')      #here \w+ is a word after -
Output -- 'egg'
----------------------------------------------------------
import re
m = re.search('(?<=-)\w+', 'abc-defgggff')
print(m.group())
Output ----defgggff
----------------------------------------------------------
import re
m = re.search('(?<=XYZ)\w+', 'abc-deXYZ1234')
print(m.group())
Output -- 1234
----------------------------------------------------------
import re
m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
print(m.group(0))       # The entire match Output -- Isaac Newton
print(m.group(1))       # The entire match Output -- Isaac
print(m.group(2))       # The entire match Output -- Newton
print(m.group(1,2))       # The entire match Output -- ('Isaac', 'Newton')
----------------------------------------------------------
 re.match() checks for a match only at the beginning of the string.  re.match("c", "abcdef")    # No match
 re.search() checks for a match anywhere in the string . re.search("c", "abcdef")   # Match
 Regular expressions beginning with '^' can be used with search() to restrict the match at the beginning of the string:
 re.search("^c", "abcdef")  # No match
 re.search("^a", "abcdef")  # Match
 
print(re.search('^A','Line1\nAllan-Line2\nSanJoseLine3', re.MULTILINE))   # Match.Here A is matched on second line 
----------------------------------------------------------
# Find all adverbs - 
text = "He was carefully disguised but captured quickly by police."
re.findall(r"\w+ly", text)           #here r is raw string notation
['carefully', 'quickly']
----------------------------------------------------------
# When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, 
# this means r"\\". Without raw string notation, one must use "\\\\", making the following lines of code functionally identical:
print(re.match(r"\\", r"\\"))      #Match
print(re.match("\\\\","\\"))       #Match
----------------------------------------------------------
\$ matches the character '$'.
\b represents the backspace character but only at the beginning or end of a word
r'\bfoo\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'.
----------------------------------------------------------
\B matches the empty string, but only when it is not at the beginning or end of a word
r'py\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'

----------------------------------------------------------
# that matches a word at end of string, with optional punctuation  
def text_match(text):
    patterns = '\w+\S*$'
    if re.search(patterns, text):
        return 'Found a match!'
    else:
        return ('Not matched!')
print(text_match("The quick brown fox jumps over the lazy dog."))      # Match
print(text_match("The quick brown fox jumps over the lazy dog. "))     # No Match
print(text_match("The quick brown fox jumps over the lazy dog"))       # Match
----------------------------------------------------------
# that matches a word containing 'z'.
'\w*z.\w*'    -- So * means any word \w . z. (z dot) means - any character except newline and \w* means any word after that
----------------------------------------------------------
# that matches a word containing 'z', not start or end of the word. 
\Bz\B
----------------------------------------------------------
# to match a string that contains only upper and lowercase letters, numbers, and underscores 
'^[a-zA-Z0-9_]*$'     
("Python_Exercises_1"))    - Match 
("jumps over the lazy dog.") - No Match
----------------------------------------------------------
# where a string will start with 5.
'^5'  
----------------------------------------------------------
# to remove leading zeros from an IP address.
ip = 102.08.09.289
re.sub('\.[0]*', '.', ip)  # 102.8.9.289
----------------------------------------------------------
m = re.match(r"(\d+)\.(\d+)", "24.1632")
m.groups()
('24', '1632')
----------------------------------------------------------
# to check for a number at the end of a string.
print(re.match(r'.*[0-9]$','thisis allan 9'))
or
print(re.match(r'.*\d$','thisis allan 9'))
----------------------------------------------------------
# to search the numbers (0-9) of length between 1 to 3 in a given string 
INPUT = "Exercises number 1, 12, 13, and 345 are important" 
Expected output - 1, 12, 13, 345 
import re
m = re.finditer(r'([0-9]{1,3})',"Exercises number 1, 12, 13, and 345 are important")
for n in m:
    print(n.group(0))
----------------------------------------------------------
# to search some literals strings in a string
Sample text : 'The quick brown fox jumps over the lazy dog.' 
Searched words : 'fox', 'dog', 'horse'  
import re
patterns = [ 'fox', 'dog', 'horse' ]
text = 'The quick brown fox jumps over the lazy dog.'
for pattern in patterns: 
    if re.search(pattern,  text):
        print('Matched!', pattern)
    else:
        print('Not Matched!')
----------------------------------------------------------
# to search a literals string in a string and also find the location within the original string where the pattern occurs. 
Sample text : 'The quick brown fox jumps over the lazy dog.'  
Searched words : 'fox'







